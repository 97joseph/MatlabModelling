{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "26ab951b",
   "metadata": {},
   "source": [
    "Content: ARTIFICIAL INTELLIGENCE"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44506889",
   "metadata": {},
   "source": [
    "Load Pretrained Network\n",
    "Load a pretrained GoogLeNet network. If the Deep Learning Toolbox™ Model for GoogLeNet Network support package is not installed, then the software provides a download link.\n",
    "\n",
    "To try a different pretrained network, open this example in MATLAB® and select a different network. For example, you can try squeezenet, a network that is even faster than googlenet. You can run this example with other pretrained networks. For a list of all available networks, see Load Pretrained Networks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9306aded",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "clear all; \n",
    "close all; \n",
    "clc; \n",
    "\n",
    "\n",
    "%Load data \n",
    "unzip('MerchData.zip');\n",
    "imds = imageDatastore('MerchData', ...\n",
    "    'IncludeSubfolders',true, ...\n",
    "    'LabelSource','foldernames'); \n",
    "[imdsTrain,imdsValidation] = splitEachLabel(imds,0.7);\n",
    "\n",
    "%Load Pretrained Network \n",
    "net = googlenet \n",
    "\n",
    "analyzeNetwork(net)\n",
    "\n",
    "%Resize the image \n",
    "net.Layers(1)\n",
    "inputSize = net.Layers(1).InputSize; \n",
    "\n",
    "%Replace Final Layers \n",
    "\n",
    "if isa(net,'SeriesNetwork') \n",
    "  lgraph = layerGraph(net.Layers); \n",
    "else\n",
    "  lgraph = layerGraph(net);\n",
    "end \n",
    "\n",
    "[learnableLayer,classLayer] = findLayersToReplace(lgraph);\n",
    "[learnableLayer,classLayer] \n",
    "\n",
    "\n",
    "\n",
    "numClasses = numel(categories(imdsTrain.Labels));\n",
    "\n",
    "if isa(learnableLayer,'nnet.cnn.layer.FullyConnectedLayer')\n",
    "    newLearnableLayer = fullyConnectedLayer(numClasses, ...\n",
    "        'Name','new_fc', ...\n",
    "        'WeightLearnRateFactor',10, ...\n",
    "        'BiasLearnRateFactor',10);\n",
    "    \n",
    "elseif isa(learnableLayer,'nnet.cnn.layer.Convolution2DLayer')\n",
    "    newLearnableLayer = convolution2dLayer(1,numClasses, ...\n",
    "        'Name','new_conv', ...\n",
    "        'WeightLearnRateFactor',10, ...\n",
    "        'BiasLearnRateFactor',10);\n",
    "end\n",
    "\n",
    "lgraph = replaceLayer(lgraph,learnableLayer.Name,newLearnableLayer);\n",
    "\n",
    "newClassLayer = classificationLayer('Name','new_classoutput');\n",
    "lgraph = replaceLayer(lgraph,classLayer.Name,newClassLayer);\n",
    "\n",
    "figure('Units','normalized','Position',[0.3 0.3 0.4 0.4]);\n",
    "plot(lgraph)\n",
    "ylim([0,10])\n",
    "layers = lgraph.Layers;\n",
    "connections = lgraph.Connections;\n",
    "\n",
    "layers(1:10) = freezeWeights(layers(1:10));\n",
    "lgraph = createLgraphUsingConnections(layers,connections);\n",
    "\n",
    "\n",
    "\n",
    "pixelRange = [-30 30];\n",
    "scaleRange = [0.9 1.1];\n",
    "imageAugmenter = imageDataAugmenter( ...\n",
    "    'RandXReflection',true, ...\n",
    "    'RandXTranslation',pixelRange, ...\n",
    "    'RandYTranslation',pixelRange, ...\n",
    "    'RandXScale',scaleRange, ...\n",
    "    'RandYScale',scaleRange);\n",
    "augimdsTrain = augmentedImageDatastore(inputSize(1:2),imdsTrain, ...\n",
    "    'DataAugmentation',imageAugmenter);\n",
    "\n",
    "%To automatically resize the validation images without performing further data augmentation, use an augmented image datastore without specifying any additional preprocessing operations.\n",
    "\n",
    "augimdsValidation = augmentedImageDatastore(inputSize(1:2),imdsValidation);\n",
    "\n",
    "%Specify the number of epochs to train for\n",
    "miniBatchSize = 10;\n",
    "valFrequency = floor(numel(augimdsTrain.Files)/miniBatchSize);\n",
    "options = trainingOptions('sgdm', ...\n",
    "    'MiniBatchSize',miniBatchSize, ...\n",
    "    'MaxEpochs',6, ...\n",
    "    'InitialLearnRate',3e-4, ...\n",
    "    'Shuffle','every-epoch', ...\n",
    "    'ValidationData',augimdsValidation, ...\n",
    "    'ValidationFrequency',valFrequency, ...\n",
    "    'Verbose',false, ...\n",
    "    'Plots','training-progress');\n",
    "\n",
    "%Train the network using the training data.\n",
    "net = trainNetwork(augimdsTrain,lgraph,options);\n",
    "\n",
    "%Classify Validation Images \n",
    "[YPred,probs] = classify(net,augimdsValidation);\n",
    "accuracy = mean(YPred == imdsValidation.Labels)\n",
    "\n",
    "%Display four sample validation images with predicted labels \n",
    "idx = randperm(numel(imdsValidation.Files),4);\n",
    "figure\n",
    "for i = 1:4\n",
    "    subplot(2,2,i)\n",
    "    I = readimage(imdsValidation,idx(i));\n",
    "    imshow(I)\n",
    "    label = YPred(idx(i));\n",
    "    title(string(label) + \", \" + num2str(100*max(probs(idx(i),:)),3) + \"%\");\n",
    "end\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "812cc59f",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8c917835",
   "metadata": {},
   "outputs": [],
   "source": [
    "CreateGraphUsingConnections"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5321bdbe",
   "metadata": {},
   "outputs": [],
   "source": [
    "% lgraph = createLgraphUsingConnections(layers,connections) creates a layer\n",
    "% graph with the layers in the layer array |layers| connected by the\n",
    "% connections in |connections|.\n",
    "\n",
    "function lgraph = createLgraphUsingConnections(layers,connections)\n",
    "\n",
    "lgraph = layerGraph();\n",
    "for i = 1:numel(layers)\n",
    "    lgraph = addLayers(lgraph,layers(i));\n",
    "end\n",
    "\n",
    "for c = 1:size(connections,1)\n",
    "    lgraph = connectLayers(lgraph,connections.Source{c},connections.Destination{c});\n",
    "end\n",
    "\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8de82462",
   "metadata": {},
   "source": [
    "Replace Final Layers\n",
    "The convolutional layers of the network extract image features that the last learnable layer and the final classification layer use to classify the input image. These two layers, 'loss3-classifier' and 'output' in GoogLeNet, contain information on how to combine the features that the network extracts into class probabilities, a loss value, and predicted labels. To retrain a pretrained network to classify new images, replace these two layers with new layers adapted to the new data set.\n",
    "\n",
    "Convert the trained network to a layer graph."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8def38c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "findLayersToReplace"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "97788062",
   "metadata": {},
   "outputs": [],
   "source": [
    "% findLayersToReplace(lgraph) finds the single classification layer and the\n",
    "% preceding learnable (fully connected or convolutional) layer of the layer\n",
    "% graph lgraph.\n",
    "function [learnableLayer,classLayer] = findLayersToReplace(lgraph)\n",
    "\n",
    "if ~isa(lgraph,'nnet.cnn.LayerGraph')\n",
    "    error('Argument must be a LayerGraph object.')\n",
    "end\n",
    "\n",
    "% Get source, destination, and layer names.\n",
    "src = string(lgraph.Connections.Source);\n",
    "dst = string(lgraph.Connections.Destination);\n",
    "layerNames = string({lgraph.Layers.Name}');\n",
    "\n",
    "% Find the classification layer. The layer graph must have a single\n",
    "% classification layer.\n",
    "isClassificationLayer = arrayfun(@(l) ...\n",
    "    (isa(l,'nnet.cnn.layer.ClassificationOutputLayer')|isa(l,'nnet.layer.ClassificationLayer')), ...\n",
    "    lgraph.Layers);\n",
    "\n",
    "if sum(isClassificationLayer) ~= 1\n",
    "    error('Layer graph must have a single classification layer.')\n",
    "end\n",
    "classLayer = lgraph.Layers(isClassificationLayer);\n",
    "\n",
    "\n",
    "% Traverse the layer graph in reverse starting from the classification\n",
    "% layer. If the network branches, throw an error.\n",
    "currentLayerIdx = find(isClassificationLayer);\n",
    "while true\n",
    "    \n",
    "    if numel(currentLayerIdx) ~= 1\n",
    "        error('Layer graph must have a single learnable layer preceding the classification layer.')\n",
    "    end\n",
    "    \n",
    "    currentLayerType = class(lgraph.Layers(currentLayerIdx));\n",
    "    isLearnableLayer = ismember(currentLayerType, ...\n",
    "        ['nnet.cnn.layer.FullyConnectedLayer','nnet.cnn.layer.Convolution2DLayer']);\n",
    "    \n",
    "    if isLearnableLayer\n",
    "        learnableLayer =  lgraph.Layers(currentLayerIdx);\n",
    "        return\n",
    "    end\n",
    "    \n",
    "    currentDstIdx = find(layerNames(currentLayerIdx) == dst);\n",
    "    currentLayerIdx = find(src(currentDstIdx) == layerNames);\n",
    "    \n",
    "end\n",
    "\n",
    "end\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d93ee144",
   "metadata": {},
   "outputs": [],
   "source": [
    "Freeze Initial Layers\n",
    "The network is now ready to be retrained on the new set of images. Optionally, you can \"freeze\" the weights of earlier layers in the network by setting the learning rates in those layers to zero. During training, trainNetwork does not update the parameters of the frozen layers. Because the gradients of the frozen layers do not need to be computed, freezing the weights of many initial layers can significantly speed up network training. If the new data set is small, then freezing earlier network layers can also prevent those layers from overfitting to the new data set.\n",
    "\n",
    "Extract the layers and connections of the layer graph and select which layers to freeze. In GoogLeNet, the first 10 layers make out the initial 'stem' of the network. Use the supporting function freezeWeights to set the learning rates to zero in the first 10 layers. Use the supporting function createLgraphUsingConnections to reconnect all the layers in the original order. The new layer graph contains the same layers, but with the learning rates of the earlier layers set to zero."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0c1c10a7",
   "metadata": {},
   "outputs": [],
   "source": [
    "% layers = freezeWeights(layers) sets the learning rates of all the\n",
    "% parameters of the layers in the layer array |layers| to zero.\n",
    "\n",
    "function layers = freezeWeights(layers)\n",
    "\n",
    "for ii = 1:size(layers,1)\n",
    "    props = properties(layers(ii));\n",
    "    for p = 1:numel(props)\n",
    "        propName = props{p};\n",
    "        if ~isempty(regexp(propName, 'LearnRateFactor$', 'once'))\n",
    "            layers(ii).(propName) = 0;\n",
    "        end\n",
    "    end\n",
    "end\n",
    "\n",
    "end\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b0d5039d",
   "metadata": {},
   "source": [
    "Get all the features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1eaf136c",
   "metadata": {},
   "outputs": [],
   "source": [
    "% Description: prepare data based on which investigation is taking place\n",
    "%\n",
    "% Inputs: x: the feature number, y: see run_investigation, im: an image, words: bag of visual words,\n",
    "% optional\n",
    "% \n",
    "% Outputs: f: the extracted feature\n",
    "function f = get_feature(x, y, im, words)\n",
    "    % make image greyscale to simplify processing complexity\n",
    "    if y == 0\n",
    "        im = im2gray(im);\n",
    "    else\n",
    "        im = my_im2gray(im);\n",
    "    end\n",
    "    switch x\n",
    "        case 2\n",
    "            % calculate average brightness of whole image\n",
    "            f = sum(im(1:1:end)) / (size(im, 1) * size(im, 2) * size(im, 3));\n",
    "        case 3\n",
    "            % generate gradients from the image using the prewitt method\n",
    "            [Gx, Gy] = imgradientxy(im, 'Prewitt');\n",
    "            % apply thresholds to generated magnitudes in order to detect clear\n",
    "            % edges\n",
    "            Gx = abs(Gx)>=45;\n",
    "            Gy = abs(Gy)>=45;\n",
    "            % collect decimals representing the amount of horizontal and vertical\n",
    "            % edges\n",
    "            f = [(sum(sum(Gx)) / (size(Gx, 1) * size(Gx, 2))) (sum(sum(Gy)) / (size(Gy, 1) * size(Gy, 2)))];\n",
    "        case 4\n",
    "            % extract hog features using typical settings\n",
    "            f = extractHOGFeatures(im, 'CellSize', [16 16], ...\n",
    "            'BlockSize', [floor(size(im,1)/16) floor(size(im,2)/16)], ...\n",
    "            'UseSignedOrientation', true);\n",
    "        case 5\n",
    "            f = words.encode(im);\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ae2ccdbd",
   "metadata": {},
   "source": [
    "KNN Calculate Distance\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bb941866",
   "metadata": {},
   "outputs": [],
   "source": [
    "% TODO: add validation?\n",
    "% Description: calculate the Euclidean distance between any two\n",
    "% points\n",
    "%\n",
    "% Inputs:\n",
    "% p: an array containing the coordinates of the first point\n",
    "% q: an array containing the coordinates of the second point\n",
    "% \n",
    "% Outputs:\n",
    "% d: a numeric value holding the straight-line distance\n",
    "% between the two points\n",
    "function d = knn_calculate_distance(p, q)\n",
    "    % square (this helps remove negative values) each of the differences and sum them then compute\n",
    "    % the square root to get the unsquared value\n",
    "    d = sqrt(sum((p-q) .^ 2));\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2b70348d",
   "metadata": {},
   "source": [
    "KNN Fit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e2618f1a",
   "metadata": {},
   "outputs": [],
   "source": [
    "% TODO: add validation?\n",
    "% Description: create a model ready to perform k-NN classification\n",
    "% from some training data\n",
    "%\n",
    "% Inputs:\n",
    "% train_examples: a numeric array containing the training examples\n",
    "% train_labels: a categorical array containing the associated\n",
    "% labels (i.e., with the same ordering as train_examples)\n",
    "% \n",
    "% Outputs:\n",
    "% m: a struct holding the parameters of the k-NN model (the\n",
    "% training examples, the training labels, and a value for k - the number of\n",
    "% nearest neighbours to use)\n",
    "function m = knn_fit(trainData, trainCat)\n",
    "    % store the values in a simple struct. Always use 3 as requested\n",
    "    m = struct('trainData', trainData, 'trainCat', trainCat, 'k', 3);\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc745b80",
   "metadata": {},
   "source": [
    "KNN Prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62fdc917",
   "metadata": {},
   "outputs": [],
   "source": [
    "% TODO: explore ways to reduce variance compared to bundled version, I\n",
    "% believe a lot of the variance is due to differences in how the mode\n",
    "% function is performed and how closeness is determined once the euclidean\n",
    "% distance is not enough \n",
    "% Description: use an existing k-NN model to classify some testing examples \n",
    "%\n",
    "% Inputs:\n",
    "% m: a struct containing details of the k-NN model we want to use\n",
    "% for classification \n",
    "% test_examples: a numeric array containing the testing examples we want to\n",
    "% classify\n",
    "% \n",
    "% Outputs:\n",
    "% predictions: a categorical array containing the predicted\n",
    "% labels (i.e., with the same ordering as test_examples)\n",
    "function predictions = knn_predict(m, testData)\n",
    "    predictions = categorical;\n",
    "    % loop over the data, it must be transposed to loop over it\n",
    "    for p = testData.'\n",
    "        i = 1;\n",
    "        % build the general array structure, ready to use\n",
    "        dists = [0,1;0,2;0,3];\n",
    "        for q = m.trainData.'\n",
    "            distNew = knn_calculate_distance(p, q);\n",
    "            switch i\n",
    "                % the cases exist to prevent null values, these can be\n",
    "                % hardcoded as only one k number is used\n",
    "                case 1\n",
    "                    dists(1,1) = distNew;\n",
    "                case 2\n",
    "                    dists(2,1) = distNew;\n",
    "                case 3\n",
    "                    dists(3,1) = distNew;\n",
    "                otherwise\n",
    "                    for d = [1:3]\n",
    "                        % ensure the smallest value is stored, because the\n",
    "                        % largest value is always replaced, it can be\n",
    "                        % determined that the 3 stored values are the\n",
    "                        % smallest without any complex comparison. Weirdly\n",
    "                        % enough, using less than or equal to results in\n",
    "                        % less variance compared to the bundled version.\n",
    "                        if dists(d,1) == max(dists(:,1)) && distNew <= min(dists(:,1))\n",
    "                            % store the new value\n",
    "                            dists(d,1) = distNew;\n",
    "                            % store the new location\n",
    "                            dists(d,2) = i;\n",
    "                        end\n",
    "                    end\n",
    "            end\n",
    "            % increment index to match the index of the next row to be\n",
    "            % compared\n",
    "            i = i + 1;\n",
    "        end\n",
    "        % fill the predictions array. because k is 3, the mode is taken out\n",
    "        % of the 3 most similar values\n",
    "        predictions(end+1,:) = mode([m.trainCat(dists(1,2)),m.trainCat(dists(2,2)),m.trainCat(dists(3,2))]);\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7098f1f",
   "metadata": {},
   "source": [
    "Image_Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6859a6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "% TODO: what if the image already is greyscale? there's also a bit of\n",
    "% variance introduced by this function, but I mean... it looks identical to\n",
    "% the image produced by the official function? I don't think it's\n",
    "% important. It also feels a bit slower, but that's definitely not a\n",
    "% priority\n",
    "% Description: convert a given image to greyscale\n",
    "%\n",
    "% Inputs:\n",
    "% im: an image\n",
    "% \n",
    "% Outputs: \n",
    "% im_g: a greyscale image consisting of uint8 values\n",
    "function im_g = my_im2gray(im)\n",
    "    % go through all the pixels\n",
    "    for i = 1:size(im, 1)\n",
    "        for j = 1:size(im, 2)\n",
    "            % store the pixel converted to greyscale, then cast it to the\n",
    "            % required data type (which also solves rounding). Use the\n",
    "            % official matlab weightings to achieve an identical result\n",
    "            im_g(i,j,:) = cast(sum([0.2989*im(i,j,1),0.587*im(i,j,2),0.114*im(i,j,3)]),'uint8');\n",
    "        end\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12b659ff",
   "metadata": {},
   "source": [
    "Check The Run Time Investigations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4a962663",
   "metadata": {},
   "outputs": [],
   "source": [
    "% Description: run an investigation on a feature\n",
    "%\n",
    "% Inputs: x: the feature number, matches up to the header, y: variable to\n",
    "% determine which functions to use: 0 - bundled, 1 - custom\n",
    "function run_investigation(x,y)\n",
    "    % re-seed the random number for reproducible results\n",
    "    rng(0);\n",
    "    % read the file's data and store it in memory\n",
    "    if x == 1\n",
    "        data = readcell('MerchData.csv');\n",
    "    else\n",
    "        data = imageDatastore('MerchData', ...\n",
    "        'IncludeSubfolders', true, ...\n",
    "        'LabelSource', 'foldernames');\n",
    "    end\n",
    "    % create a split of test:train randomised data per classification\n",
    "    % category, typically 2:3\n",
    "    switch x\n",
    "        case 1\n",
    "            data(1,:) = []; % remove the headers\n",
    "            data = data(randperm(size(data,1)),:);\n",
    "            testSize = round(0.4 * size(data,1));\n",
    "            testData = data(1:testSize,:);\n",
    "            trainData = data(testSize+1:end,:);\n",
    "        case 6\n",
    "            % use a 7:3 split, as recommended by mathworks\n",
    "            [imdsTrain, imdsTest] = splitEachLabel(data, 0.3, 'randomize');\n",
    "        otherwise\n",
    "            [imdsTrain, imdsTest] = splitEachLabel(data, 0.6, 'randomize');\n",
    "    end\n",
    "    % gather the labels\n",
    "    if x == 1\n",
    "        trainCat = categorical(trainData(:,2));\n",
    "        testCat = categorical(testData(:,2));\n",
    "    else\n",
    "        trainCat = imdsTrain.Labels;\n",
    "        testCat = imdsTest.Labels;\n",
    "    end\n",
    "    % test resnet50 on a sample image\n",
    "    if x == 6\n",
    "        % set the requested neural network\n",
    "        net = resnet50;\n",
    "        % retrieve the first test image\n",
    "        im = imdsTest.read();\n",
    "        % make sure later uses still use all images\n",
    "        imdsTest.reset;\n",
    "        % store the required size \n",
    "        imSize = net.Layers(1).InputSize; \n",
    "        % get the classification result using an image resized to meet\n",
    "        % the size requirement\n",
    "        label = classify(net,imresize(im,imSize(1:2)));\n",
    "        % report classification result\n",
    "        disp(['Resnet50 classifies this image as: ',label])\n",
    "    end\n",
    "    % prepare the data\n",
    "    switch x\n",
    "        case 1\n",
    "            % strip the categories\n",
    "            trainData(:,2) = [];\n",
    "            testData(:,2) = [];\n",
    "            % convert to matrices\n",
    "            trainData = cell2mat(trainData(:,:));\n",
    "            testData = cell2mat(testData(:,:));\n",
    "        case 6\n",
    "            % resize the images to mkae them compatible \n",
    "            imdsTrain = augmentedImageDatastore(imSize, imdsTrain);\n",
    "            imdsTest = augmentedImageDatastore(imSize, imdsTest);\n",
    "            % set feature layer\n",
    "            featureLayer = 'fc1000';\n",
    "            % collect high level features\n",
    "            trainData = activations(net, imdsTrain, featureLayer, ...\n",
    "            'MiniBatchSize', 32, 'OutputAs', 'rows');\n",
    "            testData = activations(net, imdsTest, featureLayer, ...\n",
    "            'MiniBatchSize', 32, 'OutputAs', 'rows');\n",
    "            disp('Investigation using high level features in progress...')\n",
    "        otherwise\n",
    "            % initialise arrays\n",
    "            trainData = [];\n",
    "            testData = [];\n",
    "            % one feature needs words, the rest not so much\n",
    "            if x == 5\n",
    "                words = bagOfFeatures(imdsTrain);\n",
    "            else\n",
    "                words = 0;\n",
    "            end\n",
    "            % populate arrays, feature is extracted from greyscale image\n",
    "            while hasdata(imdsTrain)\n",
    "                trainData(end+1,:) = get_feature(x, y, imdsTrain.read(), words);\n",
    "            end\n",
    "            while hasdata(imdsTest)\n",
    "                testData(end+1,:) = get_feature(x, y, imdsTest.read(), words);\n",
    "            end\n",
    "    end\n",
    "    % compute an accuracy rating for a feature\n",
    "    test_feature(testCat, testData, trainCat, trainData,y)\n",
    "    % this investigation tests multiple kinds of feature\n",
    "    if x == 6\n",
    "        % set feature layer\n",
    "        featureLayer = 'input_1';\n",
    "        % collect high level features\n",
    "        trainData = activations(net, imdsTrain, featureLayer, ...\n",
    "        'MiniBatchSize', 32, 'OutputAs', 'rows');\n",
    "        testData = activations(net, imdsTest, featureLayer, ...\n",
    "        'MiniBatchSize', 32, 'OutputAs', 'rows');\n",
    "        disp('Investigation using low level features in progress...')\n",
    "        % compute the accuracy\n",
    "        test_feature(testCat, testData, trainCat, trainData,y)\n",
    "        % create a graph of the network\n",
    "        lgraph = layerGraph(net);\n",
    "        % find layers we need in order to retrain\n",
    "        [learnableLayer,classLayer] = findLayersToReplace(lgraph);\n",
    "        % replace with the new learnable layer containing the correct\n",
    "        % number of classes\n",
    "        lgraph = replaceLayer(...\n",
    "            lgraph,...\n",
    "            learnableLayer.Name,...\n",
    "            fullyConnectedLayer(...\n",
    "                numel(categories(trainCat)), ...\n",
    "                'Name','new_fc', ...\n",
    "                'WeightLearnRateFactor',10, ...\n",
    "                'BiasLearnRateFactor',10)...\n",
    "        );\n",
    "        % swap the class layer with an empty one, this will be populated\n",
    "        % during training\n",
    "        lgraph = replaceLayer(lgraph,classLayer.Name,classificationLayer('Name','new_classoutput'));\n",
    "        % define training options\n",
    "        miniBatchSize = 10;\n",
    "        options = trainingOptions('sgdm', ...\n",
    "            'MiniBatchSize',miniBatchSize, ...\n",
    "            'MaxEpochs',6, ...\n",
    "            'InitialLearnRate',3e-4, ...\n",
    "            'Shuffle','every-epoch', ...\n",
    "            'ValidationData',imdsTest, ...\n",
    "            'ValidationFrequency',floor(numel(imdsTrain.Files)/miniBatchSize), ...\n",
    "            'Verbose',false, ...\n",
    "            'Plots','training-progress');\n",
    "        % retrain the network\n",
    "        trainNetwork(imdsTrain,lgraph,options);\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5c8d08fe",
   "metadata": {},
   "source": [
    "Test the features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "733a9ce1",
   "metadata": {},
   "outputs": [],
   "source": [
    "% Description: test a feature for the investigation and output the\n",
    "% accuracy, there's some performance variance in the custom knn functions\n",
    "%\n",
    "% Inputs: testCat, testData, trainCat, trainData,y (see run_investigation())\n",
    "function test_feature(testCat, testData, trainCat, trainData,y)\n",
    "    % train the model\n",
    "    if y == 0\n",
    "        model = fitcknn(trainData,trainCat,\"NumNeighbors\",3);\n",
    "    else\n",
    "        model = knn_fit(trainData,trainCat);\n",
    "    end\n",
    "    % use the model to predict what label each row of data will have\n",
    "    if y == 0\n",
    "        predictions = predict(model, testData);\n",
    "    else\n",
    "        predictions = knn_predict(model, testData);\n",
    "    end\n",
    "    % create a confusion matrix to aid in performance evaluation\n",
    "    [results,~] = confusionmat(testCat, predictions);\n",
    "    % create a percentage accuracy to allow easy comparison\n",
    "    a = 100 * (sum(diag(results)) / sum(results(:)));\n",
    "    % declare the accuracy\n",
    "    disp(['The accuracy is: ',num2str(a),'%'])\n",
    "end"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
